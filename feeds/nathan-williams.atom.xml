<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Brownian Motion - Nathan Williams</title><link href="https://nathanwilliams.github.io/" rel="alternate"></link><link href="https://nathanwilliams.github.io/feeds/nathan-williams.atom.xml" rel="self"></link><id>https://nathanwilliams.github.io/</id><updated>2016-07-17T20:43:00+10:00</updated><entry><title>A fresh coat of paint</title><link href="https://nathanwilliams.github.io/2016/07/17/a-fresh-coat-of-paint/" rel="alternate"></link><published>2016-07-17T20:43:00+10:00</published><updated>2016-07-17T20:43:00+10:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2016-07-17:/2016/07/17/a-fresh-coat-of-paint/</id><summary type="html">&lt;p&gt;I have wanted to get back to blogging for quite a while, but I kept being put off by octopress.
I'm more of a Python guy when it comes to scripting, and while I respect Ruby, it isn't one that works for my brain.&lt;/p&gt;
&lt;p&gt;I also hated how the content …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have wanted to get back to blogging for quite a while, but I kept being put off by octopress.
I'm more of a Python guy when it comes to scripting, and while I respect Ruby, it isn't one that works for my brain.&lt;/p&gt;
&lt;p&gt;I also hated how the content and code were mixed, it simply seems wrong.&lt;/p&gt;
&lt;p&gt;So now I am giving &lt;a href="http://blog.getpelican.com"&gt;Pelican&lt;/a&gt; a try.&lt;/p&gt;
&lt;p&gt;Not sure when or what I will write about next, but cleaning the slate is a start.&lt;/p&gt;</content><category term="blog"></category><category term="meta"></category><category term="blog"></category></entry><entry><title>Lessons from life</title><link href="https://nathanwilliams.github.io/2014/02/14/lessons-from-life/" rel="alternate"></link><published>2014-02-14T03:01:00+11:00</published><updated>2014-02-14T03:01:00+11:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2014-02-14:/2014/02/14/lessons-from-life/</id><summary type="html">&lt;h2&gt;Not a code post&lt;/h2&gt;
&lt;p&gt;I am slack about things like maintaining a blog, as you would have noticed from the gap between posts. I can come up with valid excuses, such as my wife and I having our first child, but it would still just be an excuse.
I have …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Not a code post&lt;/h2&gt;
&lt;p&gt;I am slack about things like maintaining a blog, as you would have noticed from the gap between posts. I can come up with valid excuses, such as my wife and I having our first child, but it would still just be an excuse.
I have kept meaning to get back into this, but my myriad of half finished projects never seemed to warrant it.&lt;/p&gt;
&lt;p&gt;Funnily enough, I am drawn here, compelled, to write this post, not for a project but for something I am not good at, something I endlessly struggle to comprehend and master, and that is being human.&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Warning&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;It is 3am in the morning, and my mind is racing so fast, and I am trying desperately to make this post make sense, but it is likely to be long.
Thankfully I am only really writing this for one person, I don't care what others think or if they can be bothered with this post.
&lt;!-- PELICAN_END_SUMMARY --&gt;&lt;/p&gt;
&lt;h2&gt;A stereotypical nerd&lt;/h2&gt;
&lt;p&gt;All of my life I have struggled to fit in socially, my mind treats everything like a puzzle to be solved. This is great when it comes to grappling with a new technical concept, but it is less effective when trying to understand social situations.&lt;/p&gt;
&lt;p&gt;You end up finding yourself awkward, not keeping up with the subtext and generally retreating into yourself. On the rare occasion you might find a like minded person who is ok, possibly even happy, to spend hours discussing the strengths and weaknesses of one programming paradigm over another.
Or maybe get into a discussion about determinism vs free will and not have to discuss the mundane that seems to be the social capital of everyday conversations.&lt;/p&gt;
&lt;p&gt;That is me, so what comes next is a collection of lifetime experiences and a slowly dawning realisation that kept me awake tonight.&lt;/p&gt;
&lt;h2&gt;What is in a date?&lt;/h2&gt;
&lt;p&gt;Did you notice the date on this post, does it have any significant meaning to you?
Not to me.&lt;/p&gt;
&lt;p&gt;Sure, I know what the date is, I can recall basic facts like that, but it doesn't &lt;em&gt;mean&lt;/em&gt; anything to me.
It takes my ever patient wife to subtlety hint as we go to bed that she has plans that are a secret for tomorrow.
Ugh, I failed at being human once again, I knew the date was coming, but once again I assigned no value to it and lost track of it.&lt;/p&gt;
&lt;p&gt;I need to acknowledge my wonderful wife Mindy here.
She is beyond belief thoughtful that even after the hint, she lets me know she doesn't expect anything (and honestly means it) and that she is only really doing something because it is Leila's first valentines (Leila being our 3 month old baby, if you hadn't guessed...)&lt;/p&gt;
&lt;h2&gt;Leila&lt;/h2&gt;
&lt;p&gt;We had wanted children for a while now, and now that we have one, I only wish I did it sooner.
My little girl brings more of my human side out than anything else in life.&lt;/p&gt;
&lt;p&gt;Once you get that first attempt at a smile, the first half giggle, you find yourself bending over backwards to get another.
I have become a master at pulling faces and poking out my tounge, whatever works, I am addicted and love getting that daily hit of adorable little person.&lt;/p&gt;
&lt;p&gt;So I am up at 1:30 to feed this little girl, and she is being adorable just drinking her bottle.
Her eyes are scanning the ceiling, looking at the light show of stars we have projected in her room.&lt;/p&gt;
&lt;p&gt;She is growing up and being easier to work with, she goes to bed without the slightest trouble, and ironically I find myself unable to fall back to sleep.
Instead I become reflective, and think of a couple we know, distant friends if you will.&lt;/p&gt;
&lt;h2&gt;E &amp;amp; M&lt;/h2&gt;
&lt;p&gt;I'm generally a private person, I prefer to stay in the shadows and hate when someone shines a light on me without my consent, so in that vein I am just going to refer to these friends as E &amp;amp; M.&lt;/p&gt;
&lt;p&gt;Mindy (wife) is an American expat, we met online and she moved here so we could be together.
One day early in our marriage, we went to a get together of other American expats, so Mindy could talk with others about missing home, and to have a night where her accent wasn't the minority in a room.&lt;/p&gt;
&lt;p&gt;We sat across from a more mature couple, both Americans who had moved to Australia to live.
To their left (my right) sat E &amp;amp; M, two young women around the same age as Mindy and myself.&lt;/p&gt;
&lt;p&gt;I don't know how it started, but I entered into a debate with the guy across from me, and easily enough it was about gay marriage.
Not that E &amp;amp; M bought it up, they were there like Mindy and myself, as E had just moved to Australia to be with her new found love M.&lt;/p&gt;
&lt;p&gt;As I said in the opening, I am not good in social situations, but if you get me started on something I am passionate about, I lose my sense of inhibition.
I have a strong sense of equality and fairness, so when the topic came up, I opened up and put up a good fight.&lt;/p&gt;
&lt;p&gt;Sure I would like to say I did it to defend the nice people I had just met that had a similar story as to my own, but to be honest it was all about me.
It was me believing I was right, and that this older, more conservative person simply needed to be corrected in his world view (did I mention I was young, and idealistic to think that a well placed argunment could help someone see the error of their long held beliefs?).&lt;/p&gt;
&lt;p&gt;E &amp;amp; M were nice people, and as the man's wife wisely manouvered her husband away from me, we got to have a good conversation sharing our similar histories of falling in love with people half a world away and trying to make it work.
We never became close friends, they lived a while away from us, and all four of us are somewhat introverted, but Mindy kept up with them on Facebook, so we still have some on going connection.&lt;/p&gt;
&lt;p&gt;When we met them, E was pregnant and the two were starting a family together.
A few years later, M fell pregnant and I remember Mindy relaying her frustration about being called a new mum.&lt;/p&gt;
&lt;p&gt;M would argue back that she already was a mum, E &amp;amp; M had raised a beautiful little boy together and he was their son, not just E, but M's as well.&lt;/p&gt;
&lt;h2&gt;Reflections&lt;/h2&gt;
&lt;p&gt;You might be wondering why such a long detour, but it all ties together as I was feeding Leila, and feeling a pure love for that little person, my mind bought up M's story.
As luck would have it, she had her baby days before Leila, so as Mindy posts endless pictures of our little girl, so does M (and so did E &amp;amp; M for their first child).&lt;/p&gt;
&lt;p&gt;Everything started to connect in my head, I had a strong sense of empathy for M.
I imagined if I was to be told Leila wasn't mine, and I saw myself reacting just as strongly as M did.&lt;/p&gt;
&lt;p&gt;Leila smiles at me when I enter the room, she giggles for me when we play games and she pokes her tounge out with a smile in response to my own.
She is every bit my child, no matter if biology said differently.&lt;/p&gt;
&lt;p&gt;This is where my mind started, and didn't stop.
It raced and raced, keeping me awake.&lt;/p&gt;
&lt;p&gt;I relived that debate, fought it again but with the strength of conviction borne from emotion instead of moral righteousness.
I recalled the faces of E &amp;amp; M and saw them in a new light.&lt;/p&gt;
&lt;p&gt;They didn't just have a background story in common with us, they shared something much deeper, they were clearly in love.
It not something that is easy to describe, but when you see a couple sitting next to each other, and you see the body language, you see it.&lt;/p&gt;
&lt;p&gt;In reliving that debate, I saw them next to each other, in love.
They were, just like Mindy and I, picturing a future together, hoping it would last, hoping they would be able to handle tough times ahead.&lt;/p&gt;
&lt;p&gt;They weren't special, they weren't a "lesbian couple", they were simply a couple, young and in love with each other, risking everything in the belief, hope and dreams of a long future together.&lt;/p&gt;
&lt;h2&gt;Love &amp;amp; Marriage&lt;/h2&gt;
&lt;p&gt;I have been married over 7 years now, and I like to think I have grown and learned a few things along the way.
I have come to realise that the strength of a marriage is accepting your parnters faults because they are doing that for you.&lt;/p&gt;
&lt;p&gt;If you had to defend your love for them, you might find it hard to tally up, to put it in formal writing, to make a pros &amp;amp; cons checklist that could be audited.
You can't explain it, but there is an indescibable feeling that you don't want to lose.&lt;/p&gt;
&lt;p&gt;You simply feel safer and more content when you are near them.
Sure there are times when you need time to yourself, but you never need or want to stay away too long, you need to be close to them, even if it is just sitting in the same room, quietly doing your own thing.&lt;/p&gt;
&lt;h2&gt;The two halves of marriage&lt;/h2&gt;
&lt;p&gt;As I laid awake, with these thoughts racing through my head, I came to the conclusion that there are two halves to marriage.
There is a legal side that determines how you are treated in legal and governmental proceedings and there is a more touchy feeling side where it announces to the community at large, what your intentions are towards each other.&lt;/p&gt;
&lt;p&gt;I have heard the argument before that gay people should be pragmatic and settle for getting civil unions recognised by the law, but it misses the point.
In the pragmatist view, you get 90% of what matters, and in the end who cares what others think, your love for each other doesn't depend on community acceptance.&lt;/p&gt;
&lt;p&gt;But the problem with that view is they have the ratio completely flipped.
In the true sense of marriage, you don't get married for the benefits, you get married so you can shout from the rooftops and state clearly what your intentions are towards your partner.&lt;/p&gt;
&lt;p&gt;You aren't just a couple dating, or casually seeing each other, you want people to recognise without having to ask, that you envision a shared future together where you both get old and stick through difficult times to share your life together.&lt;/p&gt;
&lt;p&gt;The legal stuff is still important, if your partner has been rushed to the emergency room, you do not want to have to beg and plead to be at their bedside, if they were to die, you do not want to fight a legal challenge from your inlaws over the custody of your child.
It is important, but it is not the reason a couple in love gets married for.&lt;/p&gt;
&lt;p&gt;I know when I propposed to Mindy I wasn't thinking of these things or the potential tax benefits that might come from being married. We are long past the times of marriage as a means to join empires.
When I decided to ask Mindy to marry me, all I was thinking of was a future where we got to be together, to spend the rest of our lives supporting each other and sharing in common joys such as our amazing little girl.&lt;/p&gt;
&lt;h2&gt;The definition of marriage&lt;/h2&gt;
&lt;p&gt;As all of this came together in my head as I struggled to sleep, it occurred to me that until now I had never fully empathised with E &amp;amp; M or other couples in their same position.
The person I was debating, kept coming back to the definition of marriage and at the time my rebuttle was that the definition has been in flux throughout human history.
But that is as sterile a response as his position, both ignored the true meaning of marriage, at least to a couple in love.&lt;/p&gt;
&lt;p&gt;When you first say the words "in sickness and in health, to death do us part", you don't fully understand the gravity of them.
Even being as introverted as I am, I have still seen enough relationships to know what I do and don't want from one.&lt;/p&gt;
&lt;p&gt;I see the ones that have lasted, and the ones that have fallen apart.
The qualities that I see as being important are the ones that embody the words we say on the day we get married.&lt;/p&gt;
&lt;p&gt;I see my mother sticking by my dad who is wasting away from a life of smoking, and in return I see him pushing past his own illness to let mum know he still loves her.&lt;/p&gt;
&lt;p&gt;I think of my mum's recently passed uncle.
Born in a different time, his life partner was always described as a friend.
Yeah, a friend that he lived with into old age, a friend that he stuck by and who stuck by him as they both deteriorated from old age.&lt;/p&gt;
&lt;p&gt;I think of my brother inlaw's parents, when his mum got alzheimer's but his dad stuck with her, he still clearly loved her as she uncontrollably forgot him.&lt;/p&gt;
&lt;p&gt;This is why I married Mindy, not for the legal concessions that come from it, but because I see a life that is only complete if I see it to the end with her.
I think of this, and then I think back to the debate and think of E &amp;amp; M.&lt;/p&gt;
&lt;p&gt;The stubborn, conservative old guy was unable to think beyond simple terms of "one man, one woman", he was unable to empathise with the young couple, to see that they loved each other.&lt;/p&gt;
&lt;p&gt;Would it last, who knows?
No one ever knows going into a relationship, you go in hoping and try to make it work.&lt;/p&gt;
&lt;p&gt;E &amp;amp; M are no different, they are no special case, they are just a couple in love and looking towards a shared future together.&lt;/p&gt;
&lt;h2&gt;Coda&lt;/h2&gt;
&lt;p&gt;This is hardly a conventional love letter, but I know Mindy and I like to think she knows me.
I hope she can see past the rambling, and my focus on others, to see the underlying message.&lt;/p&gt;
&lt;p&gt;I love you, and want to grow old with you.
I hope we never stop working on making this work, because we have a good thing here.&lt;/p&gt;
&lt;p&gt;&amp;lt;3 Natnan&lt;/p&gt;</content><category term="blog"></category><category term="reflection"></category><category term="humanity"></category></entry><entry><title>Seesaw, GUI programming the Clojure way</title><link href="https://nathanwilliams.github.io/2013/05/15/seesaw-gui-programming-the-clojure-way/" rel="alternate"></link><published>2013-05-15T17:06:00+10:00</published><updated>2013-05-15T17:06:00+10:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-05-15:/2013/05/15/seesaw-gui-programming-the-clojure-way/</id><summary type="html">&lt;p&gt;In this post we are going to look at how to make a GUI in Clojure without the ugliness that is Swing.
Seesaw is a Clojure library that wraps Swing making it easier to work with and with much less code.&lt;/p&gt;
&lt;p&gt;Keeping with the Minecraft theme, we will be expanding …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post we are going to look at how to make a GUI in Clojure without the ugliness that is Swing.
Seesaw is a Clojure library that wraps Swing making it easier to work with and with much less code.&lt;/p&gt;
&lt;p&gt;Keeping with the Minecraft theme, we will be expanding on the previous posts and visualising a Minecraft Anvil / Region file.&lt;/p&gt;
&lt;p&gt;If you are new to this series, jump back and have a look at the previous post to catch up: &lt;a href="http://nathanwilliams.github.io/2013/04/16/minecraft-region-files/"&gt;Minecraft Region Files&lt;/a&gt;&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h1&gt;Preparation&lt;/h1&gt;
&lt;p&gt;As always, the code to go along with this post can be found on GitHub, so clone the &lt;a href="https://github.com/NathanWilliams/anvil-view"&gt;anvil-view&lt;/a&gt; repo and launch a repl:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lein deps
lein repl
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;The GUI&lt;/h1&gt;
&lt;p&gt;With the REPL up, type the following to bring up the finished product:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;show-gui&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You should get the following window:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Anvil View" src="https://nathanwilliams.github.io/images/anvilview.png"&gt;&lt;/p&gt;
&lt;p&gt;So by now you may have realised that GUI layout is not my strong point!
The interface is ugly, but functional.&lt;/p&gt;
&lt;p&gt;At the top you have three menus, the first lists the Minecraft worlds you have on your computer (looking in the standard Minecraft directory), the second is the dimension and the last is the Anvil file.&lt;/p&gt;
&lt;p&gt;Below the screen is divided into four quadrants.
The top left is a representation of the header file, with white blocks being empty, and green being used.&lt;/p&gt;
&lt;p&gt;As you move the mouse over this view, the quadrant at the top right displays information for that record, and the quadrant at the bottom left highlights the data referenced by that header block.&lt;/p&gt;
&lt;p&gt;The bottom left is the layout of chunk data in the file, with the first two sectors taken by the header (each sector being 4096 bytes, and the header being 2 sectors).&lt;/p&gt;
&lt;p&gt;The bottom right was meant to be a display of NBT data, and it was almost working in a tree, but is currently disabled so this post could at least be made!&lt;/p&gt;
&lt;h1&gt;The Code&lt;/h1&gt;
&lt;p&gt;The code has been divided into a Model-View-Controller pattern, with an attempt at keeping different concepts isolated.&lt;/p&gt;
&lt;p&gt;As this post is focusing on GUI programming, it will be limited to covering the view.clj and controller.clj files.
Hopefully the rest should be reasonably easy to follow based on previous posts.&lt;/p&gt;
&lt;p&gt;To start out, lets talk about Seesaw and Swing.&lt;/p&gt;
&lt;h1&gt;Seesaw &amp;amp; Swing&lt;/h1&gt;
&lt;p&gt;If you have ever created a GUI in Java before, you will have come across Swing.
Swing is the main Java API for creating GUIs, and it is a bit of a beast to learn and work with.&lt;/p&gt;
&lt;p&gt;Seesaw is a Clojure library that wraps Swing and tries to make life more plesent, to make things clearer, and to do some of the heavy lifting for you.&lt;/p&gt;
&lt;p&gt;Seesaw can be found here: &lt;a href="https://github.com/daveray/seesaw"&gt;Seesaw&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Frames &amp;amp; Panels&lt;/h1&gt;
&lt;p&gt;To create a GUI in Swing, you need a &lt;em&gt;frame&lt;/em&gt; (a window) and you divide it up by using &lt;em&gt;panels&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Panels come in many forms and help control your layout when the size of your window changes, helping your widgets and layout stretch proportionally to each other.&lt;/p&gt;
&lt;p&gt;Open up view.clj, and look for "main-window":&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;main-window&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/frame&lt;/span&gt; &lt;span class="ss"&gt;:title&lt;/span&gt; &lt;span class="nv"&gt;title&lt;/span&gt;
            &lt;span class="ss"&gt;:width&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:width&lt;/span&gt; &lt;span class="nv"&gt;window-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ss"&gt;:height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:height&lt;/span&gt; &lt;span class="nv"&gt;window-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ss"&gt;:content&lt;/span&gt; &lt;span class="nv"&gt;window-content&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is how we define the window you saw earlier.
"sc" is the name I gave seesaw.core when I required it.
sc/frame creates a JFrame with its options being passed in as pairs of keys and values.&lt;/p&gt;
&lt;p&gt;Not all values are required, anything not specified reverts to default values.
The options above are self explanatory, but how do you know what options are available?&lt;/p&gt;
&lt;p&gt;This is one of the shining points of seesaw, it has great development support in the REPL.&lt;/p&gt;
&lt;p&gt;In the REPL you launched earlier, type the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="ss"&gt;&amp;#39;seesaw.dev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="ss"&gt;&amp;#39;seesaw.core&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;show-options&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You will get back something like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;seesaw.core.proxy$javax.swing.JFrame$Tag$a79ba523&lt;/span&gt;
                    &lt;span class="nv"&gt;Option&lt;/span&gt;  &lt;span class="nv"&gt;Notes/Examples&lt;/span&gt;
&lt;span class="nv"&gt;--------------------------&lt;/span&gt;  &lt;span class="nv"&gt;--------------&lt;/span&gt;
                    &lt;span class="ss"&gt;:class&lt;/span&gt;  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nb"&gt;keyword &lt;/span&gt;&lt;span class="nv"&gt;class&lt;/span&gt;, &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;HTML/CSS&lt;/span&gt; &lt;span class="nv"&gt;sense.&lt;/span&gt;
                            &lt;span class="nv"&gt;See&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Seesaw.core/select&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="ss"&gt;:content&lt;/span&gt;  &lt;span class="nv"&gt;The&lt;/span&gt; &lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;s&lt;/span&gt; &lt;span class="nv"&gt;main&lt;/span&gt; &lt;span class="nv"&gt;content&lt;/span&gt; &lt;span class="nv"&gt;widget&lt;/span&gt;
                     &lt;span class="ss"&gt;:icon&lt;/span&gt;
                       &lt;span class="ss"&gt;:id&lt;/span&gt;  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nb"&gt;keyword &lt;/span&gt;&lt;span class="nv"&gt;id.&lt;/span&gt;
                            &lt;span class="nv"&gt;See&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;seesaw.core/select&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="ss"&gt;:menubar&lt;/span&gt;  &lt;span class="nv"&gt;The&lt;/span&gt; &lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;s&lt;/span&gt; &lt;span class="nv"&gt;menu&lt;/span&gt; &lt;span class="nv"&gt;bar.&lt;/span&gt; &lt;span class="nv"&gt;See&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;seesaw.core/menubar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;.&lt;/span&gt;
             &lt;span class="ss"&gt;:minimum-size&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;640&lt;/span&gt; &lt;span class="ss"&gt;:by&lt;/span&gt; &lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                            &lt;span class="nv"&gt;java.awt.Dimension&lt;/span&gt;
                 &lt;span class="ss"&gt;:on-close&lt;/span&gt;  &lt;span class="ss"&gt;:hide&lt;/span&gt;
                            &lt;span class="ss"&gt;:dispose&lt;/span&gt;
                            &lt;span class="ss"&gt;:exit&lt;/span&gt;
                            &lt;span class="ss"&gt;:nothing&lt;/span&gt;
               &lt;span class="ss"&gt;:resizable?&lt;/span&gt;
                 &lt;span class="ss"&gt;:resource&lt;/span&gt;  &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;i18n&lt;/span&gt; &lt;span class="nv"&gt;prefix&lt;/span&gt; &lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;resource&lt;/span&gt; &lt;span class="nv"&gt;with&lt;/span&gt; &lt;span class="nv"&gt;keys&lt;/span&gt;
                            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:title&lt;/span&gt; &lt;span class="ss"&gt;:icon&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                     &lt;span class="ss"&gt;:size&lt;/span&gt;
                    &lt;span class="ss"&gt;:title&lt;/span&gt;  &lt;span class="nv"&gt;The&lt;/span&gt; &lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="ss"&gt;&amp;#39;s&lt;/span&gt; &lt;span class="nv"&gt;title&lt;/span&gt; &lt;span class="nv"&gt;as&lt;/span&gt; &lt;span class="nv"&gt;string&lt;/span&gt; &lt;span class="nb"&gt;or &lt;/span&gt;&lt;span class="nv"&gt;resource&lt;/span&gt; &lt;span class="nv"&gt;key&lt;/span&gt;
         &lt;span class="ss"&gt;:transfer-handler&lt;/span&gt;  &lt;span class="nv"&gt;See&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;seesaw.dnd/to-transfer-handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="ss"&gt;:undecorated?&lt;/span&gt;
                 &lt;span class="ss"&gt;:visible?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This handy tool can be used to on any of the Seesaw elements, and is really helpful for exploring what is possible.&lt;/p&gt;
&lt;p&gt;If you have read through the options above, you may have noticed the &lt;em&gt;class&lt;/em&gt; and &lt;em&gt;id&lt;/em&gt; options.
We will cover this more later, but in brief, if you have ever worked with CSS selectors, you will find these options very useful.&lt;/p&gt;
&lt;p&gt;Before we move on, we should quickly have a look at what the contents of our &lt;em&gt;main-window&lt;/em&gt; are:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;window-content&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/border-panel&lt;/span&gt;
     &lt;span class="ss"&gt;:north&lt;/span&gt;  &lt;span class="nv"&gt;world-selector&lt;/span&gt;
     &lt;span class="ss"&gt;:center&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/vertical-panel&lt;/span&gt;
                &lt;span class="ss"&gt;:items&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;header-panel&lt;/span&gt; &lt;span class="nv"&gt;sector-panel&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is the first panel we use, and it contains all other panels.
A border-panel is a "BorderLayout" in Java terms, and breaks up into five sections, the points of the compass and a centre.&lt;/p&gt;
&lt;p&gt;In this case we are only using the north (for the world selection menus) and the centre (or 'center' for our American friends!) for the rest of the GUI.&lt;/p&gt;
&lt;p&gt;If you follow the definition of each, you will find more panels dividing up those subsections in different ways.
It is almost like a set of Russian dolls, with panels inside of panels!&lt;/p&gt;
&lt;h1&gt;User Input&lt;/h1&gt;
&lt;p&gt;An interface isn't much fun if you can't interact with it, so lets look at the two ways you can interact with this interface.&lt;/p&gt;
&lt;p&gt;First we have the menus to select the anvil file to load, and then we have the mouse-over effect when you hover over the header to see the sector(s) it references.&lt;/p&gt;
&lt;h2&gt;Comboboxes&lt;/h2&gt;
&lt;p&gt;The world / dimension / file selector is implemented as a set of combobox widgets.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;world-selector&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;Used to select the world, dimension and anvil file to view&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/horizontal-panel&lt;/span&gt;
     &lt;span class="ss"&gt;:items&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;sc/combobox&lt;/span&gt; &lt;span class="ss"&gt;:model&lt;/span&gt; &lt;span class="nv"&gt;worldlist&lt;/span&gt;               &lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="ss"&gt;:worldlist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/combobox&lt;/span&gt; &lt;span class="ss"&gt;:model&lt;/span&gt; &lt;span class="nv"&gt;worlds/dimension-names&lt;/span&gt;  &lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="ss"&gt;:dimension&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/combobox&lt;/span&gt; &lt;span class="ss"&gt;:model&lt;/span&gt; &lt;span class="nv"&gt;files&lt;/span&gt;                   &lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="ss"&gt;:files&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we simply create them directly in the panel that holds them, supplying a data model and an id to reference them by later.&lt;/p&gt;
&lt;p&gt;The id is used just like an id in a HTML document and can be selected just like you would with a CSS selector.&lt;/p&gt;
&lt;p&gt;The model is just some form of data structure to fill the combobox with.
When you select a world, or a dimension, the list of files to pick from will change, so we will need to be able to change the model when that happens.&lt;/p&gt;
&lt;p&gt;When a change is detected, we can update the file list with the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;update-files&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/config!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/select&lt;/span&gt; &lt;span class="nv"&gt;main-window&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:#files&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
              &lt;span class="ss"&gt;:model&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;worlds/get-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-world&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-dimension&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is where we make use of the id we created earlier, and we update the config of the element, switching out its current model with a new one.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;select&lt;/em&gt; is Seesaw's way of getting an object without you having to hold a reference somewhere.
It takes the parent frame, and a CSS like selector.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;config!&lt;/em&gt; takes the element returned from the select, and gives it a new model value returned by the "get-files" function.&lt;/p&gt;
&lt;p&gt;Now that we have created the comboboxes, we need a way to know when they have changed and a way to get their value.&lt;/p&gt;
&lt;h2&gt;Listeners&lt;/h2&gt;
&lt;p&gt;To be notified of when an event happens on a widget, you need to register a listener.
Seesaw makes this really simply with the &lt;em&gt;listen&lt;/em&gt; function.&lt;/p&gt;
&lt;p&gt;Open controller.clj and have a look at setup-listeners&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;setup-listeners&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/listen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/select&lt;/span&gt; &lt;span class="nv"&gt;view/main-window&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:#worldlist&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
             &lt;span class="ss"&gt;:selection&lt;/span&gt; &lt;span class="nv"&gt;world-changed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/listen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/select&lt;/span&gt; &lt;span class="nv"&gt;view/main-window&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:#dimension&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
             &lt;span class="ss"&gt;:selection&lt;/span&gt; &lt;span class="nv"&gt;dimension-changed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/listen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/select&lt;/span&gt; &lt;span class="nv"&gt;view/main-window&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:#files&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
             &lt;span class="ss"&gt;:selection&lt;/span&gt; &lt;span class="nv"&gt;file-changed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/listen&lt;/span&gt; &lt;span class="nv"&gt;view/header-canvas&lt;/span&gt;
             &lt;span class="ss"&gt;:mouse-moved&lt;/span&gt; &lt;span class="nv"&gt;header-mouse-moved&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Al you need to do is pass in an object (which we get using select in this case) and pairs of events and functions to handle that event.&lt;/p&gt;
&lt;p&gt;As before, if you want to know what type of events are available for a given element, the Seesaw dev tools make it really simple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="ss"&gt;&amp;#39;seesaw.dev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;show-events&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;combobox&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gives the following list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;:action&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.ActionListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:action-performed&lt;/span&gt;
&lt;span class="ss"&gt;:component&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.ComponentListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:component-hidden&lt;/span&gt;
  &lt;span class="ss"&gt;:component-moved&lt;/span&gt;
  &lt;span class="ss"&gt;:component-resized&lt;/span&gt;
  &lt;span class="ss"&gt;:component-shown&lt;/span&gt;
&lt;span class="ss"&gt;:focus&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.FocusListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:focus-gained&lt;/span&gt;
  &lt;span class="ss"&gt;:focus-lost&lt;/span&gt;
&lt;span class="ss"&gt;:item&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.ItemListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:item-state-changed&lt;/span&gt;
&lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.KeyListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:key-pressed&lt;/span&gt;
  &lt;span class="ss"&gt;:key-released&lt;/span&gt;
  &lt;span class="ss"&gt;:key-typed&lt;/span&gt;
&lt;span class="ss"&gt;:mouse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.MouseListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-clicked&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-entered&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-exited&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-pressed&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-released&lt;/span&gt;
&lt;span class="ss"&gt;:mouse-motion&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.MouseMotionListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-dragged&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-moved&lt;/span&gt;
&lt;span class="ss"&gt;:mouse-wheel&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.MouseWheelListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:mouse-wheel-moved&lt;/span&gt;
&lt;span class="ss"&gt;:property-change&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.beans.PropertyChangeListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:property-change&lt;/span&gt;
&lt;span class="ss"&gt;:selection&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;java.awt.event.ActionListener&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:action-performed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The beauty of this system is that you don't need to make a class that conforms to a certain listener interface just to provide a simple callback method.
All you need is a Clojure function, and Seesaw does the rest.&lt;/p&gt;
&lt;p&gt;Although we don't make use of it here, &lt;em&gt;listen&lt;/em&gt; returns a function that when called removes the listener created by the call.&lt;/p&gt;
&lt;h2&gt;Getting the value&lt;/h2&gt;
&lt;p&gt;Now that you can trigger a callback on a change, all you need now is a way to get the value.&lt;/p&gt;
&lt;p&gt;Here Seesaw provides a simple function that works across all of the various widgets, simply called &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Here is how we get the selected file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;get-file&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/select&lt;/span&gt; &lt;span class="nv"&gt;main-window&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:#files&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So clean and simple, Seesaw really does make it nicer to code a GUI!&lt;/p&gt;
&lt;h1&gt;Output&lt;/h1&gt;
&lt;p&gt;All that is left now, is to show the user something in response to their actions.
In this application we have two forms of output.
One is drawing to the two canvases, and the other is textual information in a table.&lt;/p&gt;
&lt;p&gt;There were plans for a tree to display the NBT data, but that has been problematic and I didn't want to hold this post up for that one piece.&lt;/p&gt;
&lt;h2&gt;The Canvas&lt;/h2&gt;
&lt;p&gt;Drawing in the canvas consists of drawing a list of primitives such as rectangles, circles, polygons etc.&lt;/p&gt;
&lt;p&gt;Creating a canvas element in Seesaw is once again a very simple process:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;header-canvas&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/canvas&lt;/span&gt; &lt;span class="ss"&gt;:id&lt;/span&gt;         &lt;span class="ss"&gt;:headercanvas&lt;/span&gt;
             &lt;span class="ss"&gt;:background&lt;/span&gt; &lt;span class="ss"&gt;:white&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;sector-canvas&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/canvas&lt;/span&gt; &lt;span class="ss"&gt;:id&lt;/span&gt;         &lt;span class="ss"&gt;:sectorcanvas&lt;/span&gt;
             &lt;span class="ss"&gt;:background&lt;/span&gt; &lt;span class="ss"&gt;:white&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This should look familiar, and is one of the real strengths in Seesaw where the various elements all share the same creation interface.&lt;/p&gt;
&lt;p&gt;As id has been given to both canvases, but as we store them in a var, this isn't really needed.
All we are defining right now is the background colour.&lt;/p&gt;
&lt;p&gt;There isn't much more to say about them, they are really this simple!
They do however offer many more options, so don't forget to call show-options in a repl to see what is available.&lt;/p&gt;
&lt;p&gt;Now that we have a canvas, we can start drawing into them.&lt;/p&gt;
&lt;p&gt;Before we can however, we need to define a paint function.
This could have been added at creation, but to keep the code a bit clearer, I decided to delay it to a later point in the code.&lt;/p&gt;
&lt;p&gt;Changing a setting on an element is simple though, just like we did with the comboboxes, we just need to call config!:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;init-view&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="c1"&gt;; Config the paint functions etc&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/config!&lt;/span&gt; &lt;span class="nv"&gt;header-canvas&lt;/span&gt; &lt;span class="ss"&gt;:paint&lt;/span&gt; &lt;span class="nv"&gt;paint-header&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/config!&lt;/span&gt; &lt;span class="nv"&gt;sector-canvas&lt;/span&gt; &lt;span class="ss"&gt;:paint&lt;/span&gt; &lt;span class="nv"&gt;paint-body&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Starting with the header's paint function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;paint-header&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;context&lt;/span&gt; &lt;span class="nv"&gt;graphics&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;sg/draw&lt;/span&gt; &lt;span class="nv"&gt;graphics&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply concat &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render-header&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It might be a bit hard to understand this without knowing what render-header is returning, so lets try a simpler example quickly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;paint&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;draw&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;rect&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;style&lt;/span&gt; &lt;span class="ss"&gt;:foreground&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;scolor/color&lt;/span&gt; &lt;span class="ss"&gt;:black&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example would simply draw a 10x10 rectangle at 0,0 (top left of its parent) and would use draw it in black.&lt;/p&gt;
&lt;p&gt;All &lt;em&gt;draw&lt;/em&gt; takes is a sequence of primitives and the style to apply to them.
Now if you read paint-header, you should be able to guess that render-header returns a sequence of primitives and styles, we simply concat it all into a sinle sequence, and then use apply to pass the contents of that sequence to draw as arguments.&lt;/p&gt;
&lt;p&gt;The rest of the drawing routine is simply a way to create that sequence of primitives (rectangles) and their style (green if used, white / empty if not):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;render-record&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;row&lt;/span&gt; &lt;span class="nv"&gt;col&lt;/span&gt; &lt;span class="nv"&gt;rec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;sg/rect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nv"&gt;col&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nv"&gt;row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chunk-model/empty-chunk?&lt;/span&gt; &lt;span class="nv"&gt;rec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="nv"&gt;empty-style&lt;/span&gt;
     &lt;span class="nv"&gt;used-style&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;render-header&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;concat&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;map-indexed&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;z-index&lt;/span&gt; &lt;span class="nv"&gt;rowdata&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;map-indexed&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;partial &lt;/span&gt;&lt;span class="nv"&gt;render-record&lt;/span&gt; &lt;span class="nv"&gt;z-index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;rowdata&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-header&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I'm not going to go down every path here as it relies on the data models that aren't going to be examined today.
But put simply, render-header gets the value of each header record, and uses render-record to draw the appropriate rectangle.&lt;/p&gt;
&lt;p&gt;render-record is the more interesting function.
It returns a vector of two elements, the rectangle whose position is determined by the row and column of the data, and the style is selected based on if the header is refering to data with any size (an empty-chunk is defined as one having zero size).&lt;/p&gt;
&lt;p&gt;Painting the sectors is very similar, but with the addition of the highlighted sectors when you move the mouse over the header.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;sectors-per-row&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;render-sector&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rem &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;sectors-per-row&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;quot &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;sectors-per-row&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;sg/rect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;contains? &lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;highlight-sectors&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;highlight-style&lt;/span&gt;
           &lt;span class="nv"&gt;s&lt;/span&gt;                                &lt;span class="nv"&gt;used-style&lt;/span&gt;
           &lt;span class="ss"&gt;:default&lt;/span&gt;                         &lt;span class="nv"&gt;empty-style&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;render-sectors&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;concat&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;map-indexed&lt;/span&gt; &lt;span class="nv"&gt;render-sector&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;file-model/ordered-sectors&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-header&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;paint-body&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;context&lt;/span&gt; &lt;span class="nv"&gt;graphics&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;sg/draw&lt;/span&gt; &lt;span class="nv"&gt;graphics&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;render-sectors&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If the sector being drawn is in the &lt;em&gt;highlight-sectors&lt;/em&gt; atom, then it is given an orange style, if the sector is not empty (&lt;em&gt;s&lt;/em&gt; is true) it is given a green style and otherwise it is given a white / empty style.&lt;/p&gt;
&lt;p&gt;The positioning of the rectangles is a bit of a lazy hack, using a magic value &lt;em&gt;sectors-per-row&lt;/em&gt; but it kept things simple for now.&lt;/p&gt;
&lt;h2&gt;Tables&lt;/h2&gt;
&lt;p&gt;The last bit of information we have to display are things like the timestamp of the latest update for the highlighted chunk.
For this a table is used, and once again, Seesaw makes life easy.&lt;/p&gt;
&lt;p&gt;Creating the table is pretty much self explanatory by now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;header-info&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sc/table&lt;/span&gt;
   &lt;span class="ss"&gt;:model&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:columns&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="ss"&gt;:var&lt;/span&gt;   &lt;span class="ss"&gt;:text&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Variable&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="ss"&gt;:text&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;

           &lt;span class="ss"&gt;:rows&lt;/span&gt;    &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:var&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Offset&amp;quot;&lt;/span&gt;    &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:var&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Size&amp;quot;&lt;/span&gt;      &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:var&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Timestamp&amp;quot;&lt;/span&gt; &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:var&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;X&amp;quot;&lt;/span&gt;         &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:var&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Z&amp;quot;&lt;/span&gt;         &lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}]]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just like the combobox, you supply a model of your data.
The model is a vector of the columns and the rows, with each being defined in Clojure maps.
The names you give the columns, you then use in the rows, so you can supply data in any order, and even leave it out for some rows as you need to.
In this case we could have left the :value out of the rows and we would have been given empty cells instead.
Updating the values in the table is also really simple, all you need is the update-at! function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;update-header-info&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chunk-model/get-chunk&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-header&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;st/update-at!&lt;/span&gt; &lt;span class="nv"&gt;header-info&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chunk-model/chunk-sector-location&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chunk-model/chunk-sector-size&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chunk-model/chunk-timestamp&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                               &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                               &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt; &lt;span class="nv"&gt;z&lt;/span&gt;&lt;span class="p"&gt;})))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You give the table to update, and then pairs of row index and the value to change.
We don't need to change the first column (:var) just the second, so we only supply an updated value for that column.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;That ended up being a much bigger post than I expected, and I feel I left so much of the code behind.
I guess I need to learn to do these things in smaller chunks so I can post more frequently and with smaller amounts of explainations to pack in!&lt;/p&gt;
&lt;p&gt;As always, if you see a mistake in any of the above, from grammer and spelling to coding, clone the Git repo for the blog, make the change and send me a pull request.
If you have suggestions or questions, raise an issue and I will get back to you.&lt;/p&gt;
&lt;h1&gt;Next Time&lt;/h1&gt;
&lt;p&gt;I'm thinking of taking a break from Clojure &amp;amp; Minecraft for a while.
It has been a lot of fun, and a great way to improve my Clojure skills, but I am itching to do something different.&lt;/p&gt;
&lt;p&gt;Maybe some microcontrollers, or some Objective-C, I feel I have let both skills stagnate a bit, so it might be time to challenge myself again!&lt;/p&gt;</content><category term="programming"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="Region"></category><category term="Seesaw"></category><category term="Swing"></category><category term="Gui"></category></entry><entry><title>Minecraft Region files</title><link href="https://nathanwilliams.github.io/2013/04/16/minecraft-region-files/" rel="alternate"></link><published>2013-04-16T17:10:00+10:00</published><updated>2013-04-16T17:10:00+10:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-04-16:/2013/04/16/minecraft-region-files/</id><summary type="html">&lt;p&gt;Finally we start looking at actual Minecraft data files.
Today the target is the Anvil / Region file which stores all of the chunks that make up a Minecraft world.&lt;/p&gt;
&lt;p&gt;If you are new to this series, have a look at the earlier posts covering &lt;a href="http://nathanwilliams.github.com/2013/02/27/reading-minecraft-nbt-data-in-clojure-with-gloss" title="Reading Minecraft NBT data in Clojure with Gloss"&gt;NBT and Gloss&lt;/a&gt; to catch up …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Finally we start looking at actual Minecraft data files.
Today the target is the Anvil / Region file which stores all of the chunks that make up a Minecraft world.&lt;/p&gt;
&lt;p&gt;If you are new to this series, have a look at the earlier posts covering &lt;a href="http://nathanwilliams.github.com/2013/02/27/reading-minecraft-nbt-data-in-clojure-with-gloss" title="Reading Minecraft NBT data in Clojure with Gloss"&gt;NBT and Gloss&lt;/a&gt; to catch up.&lt;/p&gt;
&lt;p&gt;Now, on to the Anvil / Region file format.
From here on I am going to simply call it "Region" as this was the precursor to Anvil, with the &lt;a href="http://www.minecraftwiki.net/wiki/Region_file_format" title="Region File Format at the Minecraft Wiki"&gt;only difference&lt;/a&gt; being the NBT structure inside and the file extension.&lt;/p&gt;
&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;Preparation&lt;/h2&gt;
&lt;p&gt;The code for this blog post is on github, so you can clone the &lt;a href="https://github.com/NathanWilliams/anvil-clj"&gt;anvil-clj&lt;/a&gt; repo to follow along.&lt;/p&gt;
&lt;p&gt;After cloning it you will want to change in to the project directory, grab dependancies and start a repl:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lein deps
lein repl
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since the last post I have learnt how to have the repl start in the right namespace, so you should be in the "devel" namespace, ready to go!
From here you can look at some already decoded data by inspecting "test-header" and "test-chunk".&lt;/p&gt;
&lt;p&gt;We will cover both in more detail throught the post.&lt;/p&gt;
&lt;h2&gt;Region File&lt;/h2&gt;
&lt;p&gt;Minecraft cuts up a world into Regions and Chunks.&lt;/p&gt;
&lt;p&gt;In an earlier version of Minecraft, Chunks were stored directly on disk, one file each.
This caused problems with the number of open files and the overhead of opening files was bogging the game down. &lt;/p&gt;
&lt;p&gt;Adopted from a mod, Region files were introduced.&lt;/p&gt;
&lt;p&gt;A Region holds 32x32 Chunks, and a Chunk consists of 16x256x16 blocks.
Region files are named based on the region coordinates such as r.0.0.mca or r.-1.-9.mca&lt;/p&gt;
&lt;p&gt;But as the Minecraft world is generated on demand, not all Chunks will exist in a region.
To accomodate this without having large empty files, the Region design is almost like a file system of its own.
Everything is aligned to 4096 bytes, there is a header to find a chunk in the file, and chunks can be moved if they are too large for their sector.&lt;/p&gt;
&lt;p&gt;So now you have a high level overview, lets dig into specifics.&lt;/p&gt;
&lt;h2&gt;The Header&lt;/h2&gt;
&lt;p&gt;A Region file starts with a 8192 byte header which is split into two ZX indexed sections.
The first is a table of contents, mapping between a ZX coordinate (in Chunk coordinates relative to this file) to a location and size in the file, and the other is a table of timestamps recording when the chunk was last written to disk.&lt;/p&gt;
&lt;p&gt;Each table has 1024 4-byte entires, while the timestamps are simple 32-bit numbers, the locations table is split between offset and length.
The top 3 bytes (big endian) are an offset in 4KB 'sectors' and the 4th byte is the size in 4KB sectors.&lt;/p&gt;
&lt;h2&gt;Chunk Data&lt;/h2&gt;
&lt;p&gt;Once you have the offset and length, you can seek in the file and find the chunk you want.
Chunks are stored compressed and can be compressed with either ZLib or GZip, although only ZLib seems to be used by the game right now.&lt;/p&gt;
&lt;p&gt;A chunk has its own small header, 4-bytes indicating the actual length (minus the padding to the next 4096 byte boundry), and a single byte to indicate the compression type, 1 for GZip and 2 for ZLib.&lt;/p&gt;
&lt;p&gt;When you decompress the data you end up with an NBT encoded structure which we will leave for a future post.&lt;/p&gt;
&lt;h2&gt;Code!&lt;/h2&gt;
&lt;p&gt;Now that we know what we want, lets look at how we go about doing it all.&lt;/p&gt;
&lt;p&gt;There are three namespaces in this project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;devel&lt;/li&gt;
&lt;li&gt;world&lt;/li&gt;
&lt;li&gt;region-file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first is a little sandbox to help with repl development.
It pulls in the other two namespaces, and loads some sample data to save repetition on the repl.&lt;/p&gt;
&lt;p&gt;The world namespace is another convenience tool, which finds the Minecraft worlds saved on your computer and loads binary files (region files) into memory.
It is not a "complete" tool, it is not smart about loading, everything goes into memory and everything is cached.
It is however useful.
While developing the region library, I found myself tweaking a Minecraft creative world (with known blocks at known coordinates), and then copying the world files to the project directory to be reread which was tedious.
The world library instead allows me to simply name the world, dimension and region X,Z to load the file.&lt;/p&gt;
&lt;p&gt;And finaly, the focus of this post, the functions that make up the region library.
Here we define the file format in Gloss, find the chunk we want, decompress it and pass it to the nbt library we developed in earlier posts.&lt;/p&gt;
&lt;p&gt;The rest of this post will cover only the region-file namespace, but hopefully the other two will be clear enough to understand and work with.&lt;/p&gt;
&lt;h2&gt;Reading Region files&lt;/h2&gt;
&lt;p&gt;Compared to previous posts, this one is pretty simple.
We only have to read the file header, and individual chunks inside the file.
If you have followed this series so far, a lot of it will look familiar.&lt;/p&gt;
&lt;h2&gt;Reading the Header&lt;/h2&gt;
&lt;p&gt;Lets start backwards, from the public interface down to the inner workings.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;read-header&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;Extract the header record from a region / anvil file.&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gio/decode&lt;/span&gt; &lt;span class="nv"&gt;file-header&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;select-bytes&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;8192&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;read-header is a simple function, it chops out the first 8192 bytes (the file header), and asks Gloss to decode it using the "file-header" codec.
Getting the specific bytes is done by select-bytes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;select-bytes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="nv"&gt;offset&lt;/span&gt; &lt;span class="nv"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;Select a range of bytes from a byte buffer&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gb/take-bytes&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gb/drop-bytes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gb/create-buf-seq&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;length&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Gloss provides a nice set of take and drop like functions for working on buffer sequences (Clojure sequences of Java Buffers).
So all we need to do is drop the bytes we don't want (0 for the header, but used for chunks), and then take the number of bytes we want from there.
This might be inefficient, it requires the entire file to be loaded into memory, and is constantly copying buffered data around, but it is simple and works for our needs.
There is room to improve this if it ever shows to be a problem, but it is better to write code in a clean and easy to understand manner first, and optimise later if it is actually a bottleneck.&lt;/p&gt;
&lt;p&gt;So now we get to the interesting stuff, the file-header codec:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/defcodec&lt;/span&gt; &lt;span class="nv"&gt;file-header&lt;/span&gt;
  &lt;span class="c1"&gt;; 4 byte location  * 1024 entries = 4096 bytes&lt;/span&gt;
  &lt;span class="c1"&gt;; 4 byte timestamp * 1024 entries = 4096 bytes&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/ordered-map&lt;/span&gt;
    &lt;span class="ss"&gt;:locations&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/finite-frame&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/repeated&lt;/span&gt; &lt;span class="nv"&gt;location-frame&lt;/span&gt; &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:none&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="ss"&gt;:timestamps&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/finite-frame&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/repeated&lt;/span&gt; &lt;span class="ss"&gt;:int32&lt;/span&gt;         &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:none&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is where Gloss really shines, you get to express the layout of the header, instead of having to think about how to actually read it.
We start with an ordered-map, and split the data into two.
Each half is defined with a finite-frame, the number of bytes (half the header's 8192), and then a repeated codec to consume those bytes.&lt;/p&gt;
&lt;p&gt;Starting with the easy one, timestamps is simply a 32-bit signed integer.
So out of 4096 bytes, you get 1024 timestamp entries.
Nice and simple.&lt;/p&gt;
&lt;p&gt;Locations is a little bit more work, but not much.
To keep the codec readable, it was broken out into its own "location-frame" codec:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/defcodec-&lt;/span&gt; &lt;span class="nv"&gt;location-frame&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/compile-frame&lt;/span&gt;   &lt;span class="ss"&gt;:int32&lt;/span&gt;
                      &lt;span class="nb"&gt;identity &lt;/span&gt;         &lt;span class="c1"&gt;;writer transform&lt;/span&gt;
                      &lt;span class="nv"&gt;decode-location&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;;reader transform&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A location is also 4 bytes long (the same 1024 entries), but those bytes are split up 3/1.
To handle this we use Gloss' compile-frame which allows us to post process the returned data with a Clojure function.
That is where decode-location comes in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;decode-location&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="c1"&gt;; 4 bytes, split 3/1&lt;/span&gt;
  &lt;span class="c1"&gt;; Top 3 bytes are a file offset in 4K sectors&lt;/span&gt;
  &lt;span class="c1"&gt;; Bottom byte is the size in 4K sectors&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:offset&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;4096&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bit-shift-right &lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="ss"&gt;:size&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;4096&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bit-and &lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nv"&gt;xFF&lt;/span&gt;&lt;span class="p"&gt;))})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The location is made up of a file offset and length.
Both are in 4096-byte "sectors" and in the file all sectors are padded out to a 4096 byte boundry.
So all we have to do is shift the data down by a byte (8-bits) to get the top three bytes for the location and for the size we simply mask out the top three bytes using a bitwise and.&lt;/p&gt;
&lt;p&gt;Multiplying both numbers by 4096 gives us the actual byte location and size in the file.&lt;/p&gt;
&lt;p&gt;Before we move on to Chunks, you might have noticed the "identity" writer transform.
In the future we will be writing data back to region files, and we will need to reverse the above transformation before we write any of it to disk.
At the moment however we are only reading, so we use identity as a "no-op" function placeholder.&lt;/p&gt;
&lt;h2&gt;Reading Chunks&lt;/h2&gt;
&lt;p&gt;Now that we know where our desired chunk is, and how big it is, we can go and get it!&lt;/p&gt;
&lt;p&gt;Once again we will go from the outside in with the read-chunk function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;read-chunk&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="nv"&gt;offset&lt;/span&gt; &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;Read a chunk and decode the NBT data inside&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when-not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nbt/decode-nbt&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gio/decode&lt;/span&gt; &lt;span class="nv"&gt;chunk-codec&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;select-bytes&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;
                                &lt;span class="nv"&gt;offset&lt;/span&gt;
                                &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;  &lt;span class="c1"&gt;;This tells Gloss to ignore any padding in this &amp;quot;sector&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While a little bit bigger than read-header, there isn't much here to confuse.
We start out with a quick safety check that we aren't trying to read an empty chunk, which is helpful if you are mapping read-chunk over an entire file, as not all chunks will exist (unless ofcourse you play a lot of Minecraft!).&lt;/p&gt;
&lt;p&gt;The first big difference is decode-nbt, which takes the resulting decompressed binary data and turns it into a readable nbt data structre using the library we created in an earlier post.&lt;/p&gt;
&lt;p&gt;The other difference is the additional "false" parameter to decode.
As all chunks are stored in 4096-byte sectors, they are always rounded up and the sector is padded with zero.
Gloss however throws an exception if you don't consume all data, unless you pass a false to the optional "no-remainder?" parameter.&lt;/p&gt;
&lt;p&gt;Now we get on to the core of reading a chunk, the chunk-codec:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/defcodec&lt;/span&gt; &lt;span class="nv"&gt;chunk-codec&lt;/span&gt;
  &lt;span class="c1"&gt;;The byte layout of a chunk in a region file&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/finite-frame&lt;/span&gt; &lt;span class="ss"&gt;:int32&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/compile-frame&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/ordered-map&lt;/span&gt;
        &lt;span class="ss"&gt;:compression-type&lt;/span&gt; &lt;span class="nv"&gt;compression-type&lt;/span&gt;
        &lt;span class="ss"&gt;:data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/repeated&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt; &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:none&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="nv"&gt;compressor&lt;/span&gt;
      &lt;span class="nv"&gt;extractor&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is pretty simple, the finite-frame tells Gloss that a 32-bit integer will define the length of the following codec, and limits the data to the codec to that amount.
The inner codec takes the 1-byte compression type, and then uses repeated to consume what is left in the finite-frame as a sequence of bytes.
This, like before, is passed to a post-decoder function (extractor) which decompresses the data.&lt;/p&gt;
&lt;p&gt;As we are only reading at the moment, the compressor is just defined as the identity function for now, as we won't be using it.
So lets look at the extractor and how it works:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;extractor&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;compression-type&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;Used as a post-decoder by the chunk codec.&lt;/span&gt;
&lt;span class="s"&gt;  Decompresses either GZip or ZLib&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;byte-stream&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ByteArrayInputStream.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;byte-array&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;stream&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;compression-type&lt;/span&gt; &lt;span class="ss"&gt;:GZip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;GZIPInputStream.&lt;/span&gt; &lt;span class="nv"&gt;byte-stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;InflaterInputStream.&lt;/span&gt; &lt;span class="nv"&gt;byte-stream&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt; &lt;span class="p"&gt;[]]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;buf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;byte-array&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;We don&amp;#39;t know how big the decompressed data will be, so we read up to 1k at a time&lt;/span&gt;
            &lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.read&lt;/span&gt; &lt;span class="nv"&gt;stream&lt;/span&gt; &lt;span class="nv"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gio/to-byte-buffer&lt;/span&gt; &lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take &lt;/span&gt;&lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;seq &lt;/span&gt;&lt;span class="nv"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)))))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As this is bigger than most forms / functions we have covered so far, we will look at it in pieces.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;extractor&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:keys&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;compression-type&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you haven't seen it before, this is destructuring, and once you understand it, you will love it!
This function takes a single parameter, a map, and then pulls it apart based on its keys.
There is a lot more to destructuring than in this example, so go look into it if you haven't seen it before, it can be really help to make your code beautiful. &lt;/p&gt;
&lt;p&gt;If you look back at the chunk-codec, you will notice it had a ":compression-type" and ":data" keywords.
Destructuring like this gives us the value of those two keys in the map into variables of the same name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;byte-stream&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ByteArrayInputStream.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;byte-array&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;count &lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;stream&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;compression-type&lt;/span&gt; &lt;span class="ss"&gt;:GZip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;GZIPInputStream.&lt;/span&gt; &lt;span class="nv"&gt;byte-stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;InflaterInputStream.&lt;/span&gt; &lt;span class="nv"&gt;byte-stream&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I looked for a nice Clojure compression library, but failed to find anything.
However the Java interop isn't actually that bad.&lt;/p&gt;
&lt;p&gt;We turn the data into a new byte-array, and wrap it in a ByteArrayInputStream, from here we check the compression type and wrap it in the appropriate decompressor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt; &lt;span class="p"&gt;[]]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;buf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;byte-array&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;We don&amp;#39;t know how big the decompressed data will be, so we read up to 1k at a time&lt;/span&gt;
            &lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.read&lt;/span&gt; &lt;span class="nv"&gt;stream&lt;/span&gt; &lt;span class="nv"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gio/to-byte-buffer&lt;/span&gt; &lt;span class="nv"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;concat &lt;/span&gt;&lt;span class="nv"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take &lt;/span&gt;&lt;span class="nv"&gt;len&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;seq &lt;/span&gt;&lt;span class="nv"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)))))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The heart of it all, we read out the data at 1k chunks at a time, concat it all together and return a Gloss byte-buffer.
The 1k value is arbitrary, and other values might give better performance.&lt;/p&gt;
&lt;p&gt;We start with a loop.
If you are coming from an imperitive background, you need to forget what you know about loops.
In an imperitive language, when you get to the bottom of the loop, control jumps back to the top like a goto.
In Clojure the "loop" is a recursion target.
Now if you call "recur" inside of it, instead of recursively calling the function, it recursevley calls the loop (with tail call optimisation, so you don't consume more stack).&lt;/p&gt;
&lt;p&gt;Now, in reality, and likely under the covers, this is very much the same as an imperitive loop, but like most things, it is how you think about it that matters.&lt;/p&gt;
&lt;p&gt;So we start the loop with an empty list "result".
We make a 1k byte-array and read from the stream into it, here we are relying on the internal state of the stream, but it is a small infraction against purity for the concise code that comes out.&lt;/p&gt;
&lt;p&gt;Reading from a stream returns the number of bytes read, or -1 if you are at the end of the stream.&lt;/p&gt;
&lt;p&gt;So finally we have the "if" condition.
When we hit the end of the stream, we return the "result", converted to a Gloss byte-buffer.
If we have data remaining however, we recursively call the loop, passing in the current "result" concatenated with the bytes we just read (trimmed of course, as a stream can, and will, return a varying number of bytes from 1 to the size of your buffer).&lt;/p&gt;
&lt;p&gt;The only thing left that we haven't covered is the compression-type codec used in the chunk codec.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/defcodec&lt;/span&gt; &lt;span class="nv"&gt;compression-type&lt;/span&gt;
  &lt;span class="c1"&gt;;The file format and minecraft support both&lt;/span&gt;
  &lt;span class="c1"&gt;;But so far only ZLib is actually used&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gc/enum&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:GZip&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                  &lt;span class="ss"&gt;:ZLib&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is pretty simple and if you have read the earlier posts you should recognise it and how it works.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Reading a Region file is actually pretty easy.
So easy in fact that when I first attempted it I got carried away and started to decode the chunk NBT structure inside, mapping block IDs, biomes and more to their human readable names!&lt;/p&gt;
&lt;p&gt;As always, if you see a mistake in any of the above, from grammer and spelling to coding, clone the Git repo for the blog, make the change and send me a pull request.
If you have suggestions or questions, raise an issue and I will get back to you.&lt;/p&gt;
&lt;h2&gt;Next Time&lt;/h2&gt;
&lt;p&gt;I have something a bit more interesting in mind for next time to change things up a bit.
While I am having fun decoding these files, after a while it starts to become endless walls of text in the form of Clojure data structures.
I would like to do something a bit more visual next time, lets see how long it takes me to actually get there!&lt;/p&gt;</content><category term="programming"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="Region"></category><category term="Anvil"></category></entry><entry><title>Blind alley</title><link href="https://nathanwilliams.github.io/2013/04/11/blind-alley/" rel="alternate"></link><published>2013-04-11T07:33:00+10:00</published><updated>2013-04-11T07:33:00+10:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-04-11:/2013/04/11/blind-alley/</id><summary type="html">&lt;p&gt;I have been hacking away at reading Minecraft &lt;a href="http://www.minecraftwiki.net/wiki/Anvil_file_format"&gt;anvil&lt;/a&gt; files on and off now for over a month.
By the time I started to see results, I realised I had a teetering pile of code that was becoming hard to work with, let alone explain!&lt;/p&gt;
&lt;p&gt;So I am scrapping it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have been hacking away at reading Minecraft &lt;a href="http://www.minecraftwiki.net/wiki/Anvil_file_format"&gt;anvil&lt;/a&gt; files on and off now for over a month.
By the time I started to see results, I realised I had a teetering pile of code that was becoming hard to work with, let alone explain!&lt;/p&gt;
&lt;p&gt;So I am scrapping it and starting again, and this time I am going to document functions, and be less carefree with import!
Something good has come from this aimless hacking though, and that is a better understanding of anvil and chunks.
I feel like I better understand the concept of "writing one to throw away", it is a training exercise, or a scouting mission in a dark mineshaft!&lt;/p&gt;
&lt;p&gt;So the next series of posts will be small and focused on specific areas of functionality, eventually building up to a more complete anvil / chunk reading library.&lt;/p&gt;</content><category term="blog"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="anvil"></category></entry><entry><title>Reading Minecraft NBT data in Clojure with Gloss</title><link href="https://nathanwilliams.github.io/2013/02/27/reading-minecraft-nbt-data-in-clojure-with-gloss/" rel="alternate"></link><published>2013-02-27T08:13:00+11:00</published><updated>2013-02-27T08:13:00+11:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-02-27:/2013/02/27/reading-minecraft-nbt-data-in-clojure-with-gloss/</id><summary type="html">&lt;p&gt;So far we have covered what makes up an NBT file in &lt;a href="http://nathanwilliams.github.com/2013/02/23/exploring-minecraft-with-clojure/" title="An introduction to the NBT binary structure"&gt;Exploring Minecraft With Clojure&lt;/a&gt; and how to read binary data in Clojure using the Gloss DSL in &lt;a href="http://nathanwilliams.github.com/2013/02/25/first-steps-with-nbt-in-clojure/" title="An introduction to reading binary data with Gloss"&gt;First Steps With NBT in Clojure&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Today we are going to make a parser that can read any NBT file.
There …&lt;/p&gt;</summary><content type="html">&lt;p&gt;So far we have covered what makes up an NBT file in &lt;a href="http://nathanwilliams.github.com/2013/02/23/exploring-minecraft-with-clojure/" title="An introduction to the NBT binary structure"&gt;Exploring Minecraft With Clojure&lt;/a&gt; and how to read binary data in Clojure using the Gloss DSL in &lt;a href="http://nathanwilliams.github.com/2013/02/25/first-steps-with-nbt-in-clojure/" title="An introduction to reading binary data with Gloss"&gt;First Steps With NBT in Clojure&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Today we are going to make a parser that can read any NBT file.
There will be more code than last time, but only a small amount of it will really be new, the rest should be easy to understand based on what we have already covered.
&lt;!-- PELICAN_END_SUMMARY --&gt;&lt;/p&gt;
&lt;h2&gt;Preparation&lt;/h2&gt;
&lt;p&gt;You will want to clone the repository that accompanies this post from here &lt;a href="https://github.com/NathanWilliams/nbt-clj-reader" title="An example of reading NBT files in Clojure"&gt;nbt-clj-reader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As before, the project comes with a devel file to make setup easy, change into the project root and type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lein deps
lein repl
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At the Clojure REPL, type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;nbt-clj-reader.devel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.tools.namespace.repl&lt;/span&gt; &lt;span class="ss"&gt;:only&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gives you a "data" var, where an NBT file has already been loaded into, and a "result" var, which has the decoded value of that file.&lt;/p&gt;
&lt;h2&gt;The new stuff&lt;/h2&gt;
&lt;p&gt;As mentioned earlier, a lot of the new code should be obvious from what was covered in the previous post.
For example &lt;em&gt;tag-type&lt;/em&gt; has simply been expanded to cover all of the tags in NBT:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;enum&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:TAG_End&lt;/span&gt;        &lt;span class="mi"&gt;0&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Byte&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Short&lt;/span&gt;      &lt;span class="mi"&gt;2&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Int&lt;/span&gt;        &lt;span class="mi"&gt;3&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Long&lt;/span&gt;       &lt;span class="mi"&gt;4&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Float&lt;/span&gt;      &lt;span class="mi"&gt;5&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Double&lt;/span&gt;     &lt;span class="mi"&gt;6&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Byte_Array&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;     &lt;span class="mi"&gt;8&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_List&lt;/span&gt;       &lt;span class="mi"&gt;9&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Compound&lt;/span&gt;   &lt;span class="mi"&gt;10&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Int_Array&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Named &amp;amp; Unnamed codecs&lt;/h2&gt;
&lt;p&gt;The other new codecs such as &lt;em&gt;tag-byte&lt;/em&gt;, &lt;em&gt;tag-float&lt;/em&gt; etc are largely self explanatory, but with one big difference compared to last time, and that is that they no longer have their "name" codec defined:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-byte&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_Byte&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt;     &lt;span class="ss"&gt;:byte&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-float&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_Float&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt;     &lt;span class="ss"&gt;:float32-be&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The lack of name is due to the fact that a tag is nameless when used in a list.
For all other times, when a name is used, we handle it with a wrapper codec:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;get-named-codec&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile-frame&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt;  &lt;span class="ss"&gt;:tag-name&lt;/span&gt;    &lt;span class="nv"&gt;sized-string&lt;/span&gt;
                  &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-codec&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nb"&gt;identity &lt;/span&gt;&lt;span class="c1"&gt;;pre-encoder&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By doing this, we can have both named and unnamed codecs without having to redefine them twice.
This codec has some additional properties in adding a post-decoder callback (and a do-nothing pre-encoder callback).&lt;/p&gt;
&lt;p&gt;The codec that comes out of this function starts with a sized-string (the tag's name), and then the codec for that tag (using "get-codec" which we will cover later in this post).
Doing it like this however give a result like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Bananrama&amp;quot;&lt;/span&gt;, &lt;span class="ss"&gt;:tag-type&lt;/span&gt; &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;, &lt;span class="ss"&gt;:tag-name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When we really want something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:tag-type&lt;/span&gt; &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;, &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Bananrama&amp;quot;&lt;/span&gt;, &lt;span class="ss"&gt;:tag-name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To fix this, we add a post-decoder function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;get-codec&lt;/em&gt; is a simple function that takes a tag-type enum value, and returns the codec for that tag:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;get-codec&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:TAG_End&lt;/span&gt;        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile-frame&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:error&lt;/span&gt; &lt;span class="ss"&gt;:ErrorNoFnForEnd&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c1"&gt;; this should never be called&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Byte&lt;/span&gt;       &lt;span class="nv"&gt;tag-byte&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Short&lt;/span&gt;      &lt;span class="nv"&gt;tag-short&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Int&lt;/span&gt;        &lt;span class="nv"&gt;tag-int&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Long&lt;/span&gt;       &lt;span class="nv"&gt;tag-long&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Float&lt;/span&gt;      &lt;span class="nv"&gt;tag-float&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Double&lt;/span&gt;     &lt;span class="nv"&gt;tag-double&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Byte_Array&lt;/span&gt; &lt;span class="nv"&gt;tag-byte-array&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;     &lt;span class="nv"&gt;tag-string&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_List&lt;/span&gt;       &lt;span class="nv"&gt;tag-list&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Compound&lt;/span&gt;   &lt;span class="nv"&gt;tag-compound&lt;/span&gt;
      &lt;span class="ss"&gt;:TAG_Int_Array&lt;/span&gt;  &lt;span class="nv"&gt;tag-int-array&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In Clojure keywords act as a function for a hash-map containing them, so this function simply looks up the map and returns the desired codec.&lt;/p&gt;
&lt;h2&gt;Array codecs&lt;/h2&gt;
&lt;p&gt;A newer type of codec added is a variable length array of values.
In NBT this comes in the form of TAG_Byte_Array and TAG_Int_Array.
Both are prefixed with an int (4 bytes / 32 bits) which define how many items are in them (how many bytes, or ints).&lt;/p&gt;
&lt;p&gt;To handle this, we turn to the Gloss codec &lt;em&gt;repeated&lt;/em&gt;, which does exactly what we want, it takes a prefixed count, and then runs the supplied codec for that many iterations.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-byte-array&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_Byte_Array&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeated&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt;
                                  &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:int32-be&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-int-array&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_Int_Array&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeated&lt;/span&gt; &lt;span class="ss"&gt;:int32-be&lt;/span&gt;
                                  &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:int32-be&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In these examples, the first parameter is the codec to be repeated and the second is the prefix codec defining the length of the array.
Here the codecs are primatives, but as you will see shortly, they can be arbitrarily complex.&lt;/p&gt;
&lt;h2&gt;TAG_List and dynamic codec selection&lt;/h2&gt;
&lt;p&gt;An NBT TAG_List is defined as a list of objects that are all of the same tag, and are nameless.
As all objects in the list are the same, their tag-id doesn't need to be repeated, and is instead prefixed to the list.&lt;/p&gt;
&lt;p&gt;So the binary layout is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;children&lt;/span&gt; &lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;][...&lt;/span&gt;&lt;span class="n"&gt;taggless&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nameless&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="p"&gt;...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We know how to read the first two parts, but we need to select the right codec for the children.
This is handled by the &lt;em&gt;header&lt;/em&gt; codec.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;header&lt;/em&gt; takes three parameters, a codec that defines the following data (the children id in our case), a function that takes the result of the codec and returns a codec to decode the body, and a third function that takes the data to encode and returns a codec to encode it with.&lt;/p&gt;
&lt;p&gt;In the case of TAG_List, we need to combine the header codec and the repeated codec.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-list&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;  &lt;span class="ss"&gt;:TAG_List&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;header&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt; &lt;span class="c1"&gt;;tag-type is a frame which maps a byte to an enum name&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;;returns a repeated codec of the right length&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile-frame&lt;/span&gt;
                                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repeated&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-codec&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                              &lt;span class="ss"&gt;:prefix&lt;/span&gt; &lt;span class="ss"&gt;:int32-be&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                                &lt;span class="ss"&gt;:tag-type&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is a lot about this codec that should seem familiar.
The tag-type is just a constant so we can identify the data type later in clojure (and in the future to know how to encode it again), and we have already seen how &lt;em&gt;repeated&lt;/em&gt; and &lt;em&gt;get-codec&lt;/em&gt; work.&lt;/p&gt;
&lt;p&gt;The only thing new is &lt;em&gt;header&lt;/em&gt; which we have already started to cover.
In the tag-list codec, we use header to determine the child element type of the list, and then we use an anonymous function to build up a repeated frame for the detected codec and the count of objects.&lt;/p&gt;
&lt;p&gt;At this point you might be wondering where we read the list's tag-id and its name.
Well list is like any other tag in NBT, and it can be a nameless &amp;amp; tagless child of a list, so those things are determined by its parent tag, which brings us to the final tag that is the root of any NBT structure...&lt;/p&gt;
&lt;h2&gt;TAG_Compound &amp;amp; the root object&lt;/h2&gt;
&lt;p&gt;TAG_Compound is unique in a few different ways.
To begin with, it is the only tag that can be a root object in NBT, but it can also hold an arbirtary collection of other objects.
Finally, it is also not determined by a prefixed count as were the arrays and the list.&lt;/p&gt;
&lt;p&gt;Instead, TAG_Compound uses a terminating byte of 0x00 to signal it is complete.&lt;/p&gt;
&lt;p&gt;This causes some problems with Gloss, as it doesn't seem to have a mechanism to handle this situation.
Digging through the code, there is an undocumented "wrap-delimited-sequence" that sounds like it would work for this job, but it is unable to handle this specific case.&lt;/p&gt;
&lt;p&gt;I plan to cover Gloss in more detail in another post, so for now you will just have to take my word for it (or better yet, correct me!) and we will work through the solution.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-compound&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_Compound&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;terminated-repeat&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nv"&gt;x00&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;header&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt;
                                  &lt;span class="nv"&gt;get-named-codec&lt;/span&gt;
                                  &lt;span class="ss"&gt;:tag-type&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Following on from tag-list, there should only be one thing that stands out, and that is the "terminated-repeat" codec.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;terminated-repeat&lt;/em&gt; is not a part of Gloss, and is instead our first custom codec. What is about to follow is not pretty, and is far from complete, but it fits the requirements and allows us to read compound tags!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;Future plans include having it terminate on an arbitrary delimiter length&lt;/span&gt;
&lt;span class="c1"&gt;;and to support encoding (writing)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;terminated-repeat&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;delimiter-byte&lt;/span&gt; &lt;span class="nv"&gt;codec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;A gloss codec that repeats a sub-codec until a terminating byte is read.&lt;/span&gt;
&lt;span class="s"&gt;   This only handles a terminating byte, and can only perform reads at the moment&amp;quot;&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reify&lt;/span&gt;
    &lt;span class="nv"&gt;Reader&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-bytes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="nv"&gt;buf-seq&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;byte-codec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile-frame&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;results&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; 
               &lt;span class="nv"&gt;bufs&lt;/span&gt; &lt;span class="nv"&gt;buf-seq&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;found&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-bytes&lt;/span&gt; &lt;span class="nv"&gt;byte-codec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-bytes&lt;/span&gt;
                                                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dup-bytes&lt;/span&gt; &lt;span class="nv"&gt;bufs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                                         &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and &lt;/span&gt;&lt;span class="nv"&gt;found&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;== &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;delimiter-byte&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;== &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;byte-count&lt;/span&gt; &lt;span class="nv"&gt;bufs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="nv"&gt;results&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;drop-bytes&lt;/span&gt; &lt;span class="nv"&gt;bufs&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;success&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-bytes&lt;/span&gt; &lt;span class="nv"&gt;codec&lt;/span&gt; &lt;span class="nv"&gt;bufs&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;success&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="nv"&gt;results&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;])))))))&lt;/span&gt;  &lt;span class="c1"&gt;; This is incorrect right now&lt;/span&gt;
    &lt;span class="nv"&gt;Writer&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;write-bytes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="nv"&gt;buf&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Exception.&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;write-bytes not supported&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lets get the flaws out of the way first:
- It doesn't support writing data yet
- It doesn't handle incomplete streaming data like the rest of Gloss' codecs
- It is only designed for a single byte codec terminator&lt;/p&gt;
&lt;p&gt;I plan to add the writing side of things when I need it, and when I have more experience with that side of Gloss.
The second point refers to the line with the comment "This is incorrect right now".
When a Gloss codec completes successfully, it returns a vector of [true values remaining].
When it fails due to insufficient data for the codec, it returns [false continuation data].
By doing this, when processing streaming data, Gloss knows where to resume from, and if it is not streaming data, it can raise an error regarding insufficient bytes.&lt;/p&gt;
&lt;p&gt;I hope to get that working at some point, and I don't think it would be too difficult, but it will be a problem of having something to test against.&lt;/p&gt;
&lt;p&gt;The final flaw, being limited to a single byte codec, was a choice to keep the task simple, and as this is the only use case in NBT, I didn't see a reason to spend time on making it more general.
This could change in the future if a need for it was found.&lt;/p&gt;
&lt;p&gt;Now that I have gotten that out of the way, a brief explaination of how this codec works.
To start with it makes a copy of the byte-buffers, and takes a single byte.
It compares this against the terminator, and if it matches, ir returns what it has so far.
If it doesn't, it uses the child codec on the data once, and recurs on itself.&lt;/p&gt;
&lt;p&gt;Looking back at tag-compound, you will notice that the codec given is a &lt;em&gt;header&lt;/em&gt;, so each child can be different, and is determined and processed based on their type-id.&lt;/p&gt;
&lt;h2&gt;The root of it all&lt;/h2&gt;
&lt;p&gt;So if you have been paying attention, you might have noticed that tag-compound is also missing its tag-id and name.
As with a list, it can also be a child of a list or compound, so its name may not be needed and its tag-id would be consumed by its parent's &lt;em&gt;header&lt;/em&gt; codec.&lt;/p&gt;
&lt;p&gt;To end the infinite regress, we have one final codec:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nb"&gt;root &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;header&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt;
                       &lt;span class="nv"&gt;get-named-codec&lt;/span&gt;
                       &lt;span class="ss"&gt;:tag-type&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By now this should be pretty clear.
It will always return a tag-compound, and we could have hardcoded that in, I just thought this looked cleaner.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This wraps up the series of reading Minecraft NBT data, I plan to cover writing NBT data in future posts.
I also have plans on diving into how Gloss works, as I learned a lot by digging through the source and working out how to make my own codec.&lt;/p&gt;
&lt;p&gt;If you see any mistakes, please clone the blog post (it is on GitHub), make the changes and send me a pull request.
If you have suggestions on how I could improve, or if I didn't make something clear, raise an issue and I will do my best to answer it.&lt;/p&gt;</content><category term="programming"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="NBT"></category><category term="Gloss"></category></entry><entry><title>First steps with NBT in Clojure</title><link href="https://nathanwilliams.github.io/2013/02/25/first-steps-with-nbt-in-clojure/" rel="alternate"></link><published>2013-02-25T12:54:00+11:00</published><updated>2013-02-25T12:54:00+11:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-02-25:/2013/02/25/first-steps-with-nbt-in-clojure/</id><summary type="html">&lt;p&gt;In the &lt;a href="http://nathanwilliams.github.com/2013/02/23/exploring-minecraft-with-clojure/" title="Exploring Minecraft with Clojure"&gt;last post&lt;/a&gt; we covered the basics of the NBT structure.
Now it is time to start reading a basic NBT test file.
I am going to start with "test.nbt" provided by Markus Persson (aka Notch), and in this entry we are  going to do the bare minimum …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the &lt;a href="http://nathanwilliams.github.com/2013/02/23/exploring-minecraft-with-clojure/" title="Exploring Minecraft with Clojure"&gt;last post&lt;/a&gt; we covered the basics of the NBT structure.
Now it is time to start reading a basic NBT test file.
I am going to start with "test.nbt" provided by Markus Persson (aka Notch), and in this entry we are  going to do the bare minimum to read the file.&lt;/p&gt;
&lt;p&gt;This post assumes a working Clojure environment, including Leiningen.&lt;/p&gt;
&lt;h2&gt;Reading Binary data in Clojure&lt;/h2&gt;
&lt;p&gt;To start off, we need to decide how to read the binary files in Clojure.
We could drop down to Java and use java.nio, but that seems so primitive...
&lt;!-- PELICAN_END_SUMMARY --&gt;&lt;/p&gt;
&lt;h2&gt;Enter Gloss&lt;/h2&gt;
&lt;p&gt;A better option is the &lt;a href="https://github.com/ztellman/gloss" title="Gloss DSL"&gt;Gloss&lt;/a&gt; DSL / library, which provides a nice, high level way of processing binary data in Clojure.&lt;/p&gt;
&lt;p&gt;With Gloss you specify what makes up a "frame" and compile it into a codec which you can use to decode or encode structured binary data.
A frame consists of other codecs, and eventually all codecs come down to primitive values such as bytes, numbers and strings.&lt;/p&gt;
&lt;p&gt;Gloss also provides a set of codecs that handle variable length data, such as repeated.
Instead of covering what is available in Gloss, you should have a quick look at its &lt;a href="https://github.com/ztellman/gloss/wiki/Introduction" title="An introduction to Gloss"&gt;Introduction page&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Preparation&lt;/h2&gt;
&lt;p&gt;Before we go any further, make a clone of the repo for this post here: &lt;a href="https://github.com/NathanWilliams/nbt-basic"&gt;nbt-basic&lt;/a&gt;
This provides the end result to this post, but also provides the test file and some code to load it for easy experimentation in the repl.&lt;/p&gt;
&lt;p&gt;Once you clone the repository, change into the project directory, and run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lein deps
lein repl
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From here you will want to change into the 'nbt-basic.devel' namespace, and load the 'refresh' function from the tools lib, and finally call refresh&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;nbt-basic.devel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.tools.namespace.repl&lt;/span&gt; &lt;span class="ss"&gt;:only&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will make sure everything is loaded, and that you can easily access the already loaded data file.
If you make any changes to the files, simply call refresh again, which will clear out the repl environment and reload any changes.&lt;/p&gt;
&lt;h2&gt;The Goal&lt;/h2&gt;
&lt;p&gt;The plan for this post is to handle the simple test.nbt file, which decoded looks something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;TAG_Compound(&amp;#39;hello world&amp;#39;): 1 entry&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="err"&gt;    TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Bananrama&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The byte data looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;0a 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 08 00&lt;/span&gt;
&lt;span class="err"&gt;04 6e 61 6d 65 00 09 42 61 6e 61 6e 72 61 6d 61&lt;/span&gt;
&lt;span class="err"&gt;00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Referencing back to the NBT specification on the &lt;a href="http://mc.kev009.com/NBT" title="The NBT spec on the MinecraftCoalition wiki"&gt;MinecraftCoalition wiki page&lt;/a&gt;, we can start to decode the data.
Looking at the specification, we have the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All files start with a TAG_Compound&lt;/li&gt;
&lt;li&gt;A TAG_Compound starts with an ID of 10 (0x0a) and is terminated by a TAG_End which has an ID of 0 (0x00)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So lets start with the simplest thing that would work:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-compound-ugly&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt;  &lt;span class="ss"&gt;:tag-type&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt;
                &lt;span class="ss"&gt;:tag-name&lt;/span&gt; &lt;span class="nv"&gt;sized-string&lt;/span&gt;
                &lt;span class="ss"&gt;:child&lt;/span&gt;    &lt;span class="nv"&gt;tag-type&lt;/span&gt;
                &lt;span class="ss"&gt;:payload&lt;/span&gt;  &lt;span class="nv"&gt;tag-string&lt;/span&gt;
                &lt;span class="ss"&gt;:end&lt;/span&gt;      &lt;span class="ss"&gt;:byte&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This codec is almost useless as it is hardcoded for this file structure only, but it serves a purpose of explaining a few Gloss concepts.&lt;/p&gt;
&lt;p&gt;At the repl, type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;decode&lt;/span&gt; &lt;span class="nv"&gt;tag-compound-ugly&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You should get the following out:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:end&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;, &lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:payload&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Bananrama&amp;quot;&lt;/span&gt;, &lt;span class="ss"&gt;:tag-name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;, &lt;span class="ss"&gt;:tag-type&lt;/span&gt; &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;, &lt;span class="ss"&gt;:child&lt;/span&gt; &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;, &lt;span class="ss"&gt;:tag-name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;, &lt;span class="ss"&gt;:tag-type&lt;/span&gt; &lt;span class="ss"&gt;:TAG_Compound&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you look back at the decoded version of this file shown earlier, you should see that our codec has worked!&lt;/p&gt;
&lt;p&gt;But how did it work?
Lets break it down into its component pieces.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defcodec&lt;/strong&gt;: This simply compiles the frame and binds it to a var, and is equivalent to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nb"&gt;name &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile-frame&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;compile-frame&lt;/strong&gt;: This takes either a single codec, a vector of codecs, a map or an &lt;em&gt;ordered-map&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single codec can be anything from a primative (numbers, strings) to something like a &lt;em&gt;repeated&lt;/em&gt; construct.&lt;/li&gt;
&lt;li&gt;A vector is ordered, and the codec will produce a vector on decode, and consume one on encode.&lt;/li&gt;
&lt;li&gt;A map is a normal Clojure map and is not ordered.
  The order is consistent however, which is useful for working with other Gloss code, but cannot be used with an already defined binary format order.&lt;/li&gt;
&lt;li&gt;An ordered-map is a Gloss construct that allows you to use a Clojure map on encode &amp;amp; decode, whilst maintaining the defined order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;frames&lt;/strong&gt;: Along with codecs, a frame can take constant values, which are not taken from the binary data on decoding, and are not added on encoding.
Instead, these are useful for providing map keys, or other constants such as an internal name, to help identification in the rest of your code.&lt;/p&gt;
&lt;p&gt;If you look at our &lt;em&gt;tag-compound-ugly&lt;/em&gt;, you will see a list of keys, paired with codecs.
All of the codecs (except for the final ":byte") are defined in the project repository that you cloned previously, in "src/nbt_basic/nbt.clj".&lt;/p&gt;
&lt;p&gt;So now we can look at how each of these codecs are defined, so we can put the whole picture together.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tag-type&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;enum&lt;/span&gt; &lt;span class="ss"&gt;:byte&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:TAG_String&lt;/span&gt;     &lt;span class="mi"&gt;8&lt;/span&gt;
                                &lt;span class="ss"&gt;:TAG_Compound&lt;/span&gt;   &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The tag-type codec uses Gloss' &lt;em&gt;enum&lt;/em&gt; codec, which takes a primative codec, and converts between the raw value and what you provide.
This allows you to turn magic values from a binary format into something readable.
This implementation of tag-type is incomplete, only covering the two data types in the test.nbt file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sized-string&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;sized-string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;finite-frame&lt;/span&gt; &lt;span class="ss"&gt;:uint16-be&lt;/span&gt;
                                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="ss"&gt;:utf-8&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The sized-string codec wraps a string codec in a &lt;em&gt;finite-frame&lt;/em&gt;.
The finite-frame takes a codec which returns a count of bytes, and then gives that number of bytes to its child codec, in this case a utf-8 string.
This matches the NBT specification which marks a string (both the name of an object, and the contents of a TAG_String) with an unsigned short (16 bits / 2 bytes) in big-endian format (hence the -be postfix).&lt;/p&gt;
&lt;p&gt;And finally we have &lt;em&gt;tag-string&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defcodec&lt;/span&gt; &lt;span class="nv"&gt;tag-string&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ordered-map&lt;/span&gt; &lt;span class="ss"&gt;:tag-type&lt;/span&gt;    &lt;span class="ss"&gt;:TAG_String&lt;/span&gt;
               &lt;span class="ss"&gt;:tag-name&lt;/span&gt;    &lt;span class="nv"&gt;sized-string&lt;/span&gt;
               &lt;span class="ss"&gt;:payload&lt;/span&gt;     &lt;span class="nv"&gt;sized-string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With the exception of TAG_List items (which we will cover another time), NBT tags are named.
So a TAG_String consists of two &lt;em&gt;sized-string&lt;/em&gt; codecs, one for the tag's name, and the other its contents. &lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have covered a lot of stuff, but it doesn't feel we have gotten very far!
That is going to change quickly, now that you have a better understanding of how Gloss works, next time we will cover a complete reader that will be able to read any NBT structure.&lt;/p&gt;
&lt;h2&gt;Feedback&lt;/h2&gt;
&lt;p&gt;As before, if you see something wrong, fork this blog post on GitHub, fix it and send me a pull request.
If you have questions or suggestions, please raise a ticket against it and I'll get back to you.&lt;/p&gt;</content><category term="programming"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="NBT"></category><category term="Gloss"></category></entry><entry><title>Exploring Minecraft with Clojure</title><link href="https://nathanwilliams.github.io/2013/02/23/exploring-minecraft-with-clojure/" rel="alternate"></link><published>2013-02-23T06:14:00+11:00</published><updated>2013-02-23T06:14:00+11:00</updated><author><name>Nathan Williams</name></author><id>tag:nathanwilliams.github.io,2013-02-23:/2013/02/23/exploring-minecraft-with-clojure/</id><summary type="html">&lt;p&gt;After years of ignoring it, I have become hooked on Minecraft after a single try.
Looking from the outside, all you see is a low resolution, blocky world; but jump in and you find yourself in a vast, detailed expanse.&lt;/p&gt;
&lt;p&gt;The low resolution fades before your eyes.
Like a good …&lt;/p&gt;</summary><content type="html">&lt;p&gt;After years of ignoring it, I have become hooked on Minecraft after a single try.
Looking from the outside, all you see is a low resolution, blocky world; but jump in and you find yourself in a vast, detailed expanse.&lt;/p&gt;
&lt;p&gt;The low resolution fades before your eyes.
Like a good book, your imagination fills the gaps, you don't see a lego shaped hill, you see a mountain forged through eons of time.&lt;/p&gt;
&lt;p&gt;Before you know what has happened, you have made a mark on that world.
You own it, you mold it, you get a feel for the lay of the land, you push boundries and find them surprisingly maleable.
The pieces might be simple, but the outcome is rich and intricate.&lt;/p&gt;
&lt;p&gt;I find something deeply similar with Clojure.
From the outside you see a strange syntax, terse and compact, you wonder how anything can be done in it.
Where is the required boilerplate you need to paste in, where is the dense documentation to wade through?&lt;/p&gt;
&lt;p&gt;But you jump in anyway.
You struggle at first, your previous experience didn't prepared you for this, but you see something special, so you persist.
Before you know it, you have made something interesting, and the result is elegant and compact.&lt;/p&gt;
&lt;p&gt;The strange syntax fades, and you don't miss the verbosity you once thought was necessary to achieve impressive feats.&lt;/p&gt;
&lt;h2&gt;Exploration&lt;/h2&gt;
&lt;p&gt;So how does this journey begin you ask?
Like any good Clojure task, we are going to start from low level building blocks and compose our way to something bigger.
The starting point of this expedition is in reading the &lt;a href="http://mc.kev009.com/NBT" title="The NBT spec on the MinecraftCoalition wiki"&gt;Named Binary Tag&lt;/a&gt; data structure that is used extensively in Minecraft data files and network communications.
&lt;!-- PELICAN_END_SUMMARY --&gt;&lt;/p&gt;
&lt;h2&gt;The NBT format&lt;/h2&gt;
&lt;p&gt;NBT is a simple binary format that stores data tagged by type, and unless part of list, they are also named.
Here is a simple example of a (decoded) NBT structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;TAG_Compound(&amp;#39;hello world&amp;#39;): 1 entry&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="err"&gt;    TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Bananrama&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On disk, this file looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;0000000 0a 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 08 00&lt;/span&gt;
&lt;span class="err"&gt;0000010 04 6e 61 6d 65 00 09 42 61 6e 61 6e 72 61 6d 61&lt;/span&gt;
&lt;span class="err"&gt;0000020 00                                             &lt;/span&gt;
&lt;span class="err"&gt;0000021&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The format allows more than just a flat group of objects, elements can be nested inside compound and list data structures to an arbitrary depth.&lt;/p&gt;
&lt;p&gt;Here is a more complex example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt; TAG_Compound(&amp;#39;Level&amp;#39;): 11 entries&lt;/span&gt;
&lt;span class="err"&gt; {&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Compound(&amp;#39;nested compound test&amp;#39;): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;   {&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Compound(&amp;#39;egg&amp;#39;): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;     {&lt;/span&gt;
&lt;span class="err"&gt;       TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Eggbert&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;       TAG_Float(&amp;#39;value&amp;#39;): 0.5&lt;/span&gt;
&lt;span class="err"&gt;     }&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Compound(&amp;#39;ham&amp;#39;): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;     {&lt;/span&gt;
&lt;span class="err"&gt;       TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Hampus&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;       TAG_Float(&amp;#39;value&amp;#39;): 0.75&lt;/span&gt;
&lt;span class="err"&gt;     }&lt;/span&gt;
&lt;span class="err"&gt;   }&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Int(&amp;#39;intTest&amp;#39;): 2147483647&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Byte(&amp;#39;byteTest&amp;#39;): 127&lt;/span&gt;
&lt;span class="err"&gt;   TAG_String(&amp;#39;stringTest&amp;#39;): &amp;#39;HELLO WORLD THIS IS A TEST STRING \xc3\x85\xc3\x84\xc3\x96!&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;   TAG_List(&amp;#39;listTest (long)&amp;#39;): 5 entries&lt;/span&gt;
&lt;span class="err"&gt;   {&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Long(None): 11&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Long(None): 12&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Long(None): 13&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Long(None): 14&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Long(None): 15&lt;/span&gt;
&lt;span class="err"&gt;   }&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Double(&amp;#39;doubleTest&amp;#39;): 0.49312871321823148&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Float(&amp;#39;floatTest&amp;#39;): 0.49823147058486938&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Long(&amp;#39;longTest&amp;#39;): 9223372036854775807L&lt;/span&gt;
&lt;span class="err"&gt;   TAG_List(&amp;#39;listTest (compound)&amp;#39;): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;   {&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Compound(None): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;     {&lt;/span&gt;
&lt;span class="err"&gt;       TAG_Long(&amp;#39;created-on&amp;#39;): 1264099775885L&lt;/span&gt;
&lt;span class="err"&gt;       TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Compound tag #0&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;     }&lt;/span&gt;
&lt;span class="err"&gt;     TAG_Compound(None): 2 entries&lt;/span&gt;
&lt;span class="err"&gt;     {&lt;/span&gt;
&lt;span class="err"&gt;       TAG_Long(&amp;#39;created-on&amp;#39;): 1264099775885L&lt;/span&gt;
&lt;span class="err"&gt;       TAG_String(&amp;#39;name&amp;#39;): &amp;#39;Compound tag #1&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;     }&lt;/span&gt;
&lt;span class="err"&gt;   }&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Byte_Array(&amp;#39;byteArrayTest (the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))&amp;#39;): [1000 bytes]&lt;/span&gt;
&lt;span class="err"&gt;   TAG_Short(&amp;#39;shortTest&amp;#39;): 32767&lt;/span&gt;
&lt;span class="err"&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I'm not going to cover the entire NBT specification, as it is already well covered on the &lt;a href="http://mc.kev009.com/NBT" title="The NBT spec on the MinecraftCoalition wiki"&gt;MinecraftCoalition wiki page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are however a few gotchas that might trip you up along the way.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TAG_Byte_Array &amp;amp; TAG_Int_Array don't hold tagged data, only raw bytes / integers.&lt;/li&gt;
&lt;li&gt;Every tag starts with a single byte for type id.&lt;/li&gt;
&lt;li&gt;Tags contain a string name, which is the same structure as a TAG_String, just without the string tag id.&lt;/li&gt;
&lt;li&gt;TAG_List breaks the above two rules (tag id and name) for its immediate child nodes. 
  A TAG_List contains the tag id for its child objects, so all direct decendant nodes are of the same type, and a signed integer indicating the number of elements in the list.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I know we haven't covered any Clojure yet, but I wanted to get the basics out of the way first, so we can jump into code without having to go back and forth constantly.
The next entry we will look at reading a simple NBT file, covering the bare minimum, and then building from there.&lt;/p&gt;
&lt;h2&gt;Feedback&lt;/h2&gt;
&lt;p&gt;You may have noticed the lack of comments on this blog.&lt;/p&gt;
&lt;p&gt;This is a concious decision, but it doesn't mean I don't want feedback.
If you see something wrong from typos and grammer to bad coding practices, I want to know!&lt;/p&gt;
&lt;p&gt;This blog is hosted on &lt;a href="https://github.com/NathanWilliams/nathanwilliams.github.com/tree/source" title="Blog source tree"&gt;GitHub&lt;/a&gt; so feel free to fork it, make corrections and issue a pull request.
You can also raise a ticket to suggest improvements, or ask for clarification on anything I haven't explained clearly.&lt;/p&gt;</content><category term="programming"></category><category term="Clojure"></category><category term="Minecraft"></category><category term="NBT"></category></entry></feed>